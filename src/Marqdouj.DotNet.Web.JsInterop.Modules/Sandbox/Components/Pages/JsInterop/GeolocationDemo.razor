@page "/geolocation"
@using Marqdouj.DotNet.Web.JsInterop.Modules.Geolocation
@rendermode InteractiveServer
@implements IAsyncDisposable
@inject IToastService ToastService
@inject ILogger<GeolocationDemo> Logger
@inject IJSRuntime JSRuntime

<PageTitle>Geolocation</PageTitle>

<FluentLayout>
    <FluentHeader>Geolocation</FluentHeader>

    <FluentToolbar>
        <FluentButton Disabled="@disabledGetLocation" IconStart="@(new Icons.Regular.Size20.GlobeSearch())" Title="Get Current Location" OnClick="@GetCurrentPosition" />
        <FluentSpacer Width="3" />
        <FluentButton Disabled="@disabledWatching" IconStart="@(new Icons.Regular.Size20.EyeTracking())" Title="Start Watch" OnClick="@(() => GeolocationWatch(true))" />
        <FluentButton Disabled="@disabledNotWatching" IconStart="@(new Icons.Regular.Size20.EyeTrackingOff())" Title="Stop Watch" OnClick="@(() => GeolocationWatch(false))" />
        <FluentButton Disabled="@disabled" IconStart="@(new Icons.Regular.Size20.Info())" Title="Check Watch" OnClick="@IsWatched" />
    </FluentToolbar>

    <FluentCard>
        <FluentLabel>Success: @geolocationResult?.IsSuccess</FluentLabel>
        <FluentLabel>Position: @geolocationResult?.Position</FluentLabel>
        <FluentLabel>Error: @geolocationResult?.Error</FluentLabel>
    </FluentCard>
</FluentLayout>

<FluentOverlay @bind-Visible="@overlay"
               Transparent="false">
    <FluentProgressRing />
</FluentOverlay>

@code {
    private const string key = "geoKey";
    private GeolocationInterop? interop;
    private bool overlay;
    private bool disabled => overlay || interop == null;
    private bool isWatching;
    private bool isNotWatching => !isWatching;
    private bool disabledWatching => disabled || isWatching;
    private bool disabledNotWatching => disabled || isNotWatching;
    private bool disabledGetLocation => disabled || isWatching;
    private GeolocationResult? geolocationResult;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            interop = new(JSRuntime);
            await Task.CompletedTask;
            //await interop.SetLogLevel(LogLevel.Debug);
            //interop.OnGeolocationWatch += OnGeolocationWatch;
            interop.OnGeolocationWatchAsync += OnGeolocationWatchAsync;
            StateHasChanged();
        }
    }

    private async Task GetCurrentPosition()
    {
        try
        {
            if (interop is null) return;

            overlay = true;

            await UpdateGeolocationAsync(null);
            var geolocation = await interop.GetLocation(new PositionOptions { EnableHighAccuracy = true });

            if (geolocation != null)
            {
                if (geolocation.IsSuccess)
                {
                    await UpdateGeolocationAsync(geolocation);
                }
                else
                {
                    var errMsg = $"Geolocation service failed. {geolocation.Error?.Message}";
                    Logger?.LogError(errMsg);
                    ToastService.ShowError(errMsg);
                }
            }
            else
            {
                var warnMsg = $"Geolocation service returned null.";
                Logger?.LogWarning(warnMsg);
                ToastService.ShowWarning(warnMsg);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.ShowError(ex.Message);
        }
        finally
        {
            overlay = false;
        }
    }


    private async Task GeolocationWatch(bool watch)
    {
        try
        {
            if (interop is null) return;
            if (watch && isWatching) return;
            if (!watch && isNotWatching) return;

            if (watch)
            {
                await UpdateGeolocationAsync(null);
                await interop.WatchPosition(key);
                isWatching = true;
                ToastService.ShowInfo($"Waiting for first Geolocation Watch event...");
            }
            else
            {
                await RemoveWatch();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.ShowError(ex.Message);
        }
    }

    private async Task RemoveWatch()
    {
        try
        {
            if (interop is null) return;
            if (isWatching)
            {
                await interop.ClearWatch(key);
                isWatching = false;
                await UpdateGeolocationAsync(null);
                ToastService.ShowInfo($"Geolocation watch was removed.");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.ShowError(ex.Message);
        }
    }

    private void UpdateGeolocation(GeolocationResult? geolocation)
    {
        if (interop == null) return;

        geolocationResult = geolocation;
        StateHasChanged();

        if (geolocation is not null)
            ToastService.ShowInfo($"Geolocation updated: {geolocation}");
    }

    private async Task UpdateGeolocationAsync(GeolocationResult? geolocation)
    {
        await Task.CompletedTask;
        UpdateGeolocation(geolocation);
    }

    private async Task IsWatched()
    {
        try
        {
            var watched = await interop!.IsWatched(key);
            ToastService.ShowInfo($"Geolocation is being watched: {watched}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.ShowError(ex.Message);
        }
    }

    private void OnGeolocationWatch(GeolocationEventArgs e)
    {
        try
        {
            ToastService.ShowInfo($"Geolocation Watch event received. Success:{e.IsSuccess}");
            UpdateGeolocation(e.Result!);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.ShowError(ex.Message);
        }
    }

    private async Task OnGeolocationWatchAsync(GeolocationEventArgs e)
    {
        await Task.CompletedTask;
        OnGeolocationWatch(e);
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (interop is not null)
                await interop!.DisposeAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
        }
    }
}
